{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python validating types (vtypes) \u00b6 Validating types for python - use isinstance() to validate both type and value. vtypes is a small library to define \"validating types\". These types can be used to add value validation on top of type checking anywhere where you usually rely on isinstance() . This can in particular be used to make validation schemas simpler and more readable, for example used in pyfields . Installing \u00b6 > pip install vtypes Usage \u00b6 a - basics \u00b6 A VType is a combination of : a type name , for example 'PositiveInt' one or several base types : for example int . one or several validators : for example lambda x: x >= 0 For example we can create a positive int: from vtypes import vtype PositiveInt = vtype ( 'PositiveInt' , int , { 'should be positive' : lambda x : x >= 0 }) A VType 's main purpose is to behave like a type (therefore to be compliant with isinstance ) and to validate both type and values at the same time when isinstance is called: assert isinstance ( 1 , PositiveInt ) assert not isinstance ( - 1 , PositiveInt ) b - goodies \u00b6 In addition to this primary feature, a VType provides a few handy methods: detailed error messages with validate (note: a variable name should be provided, for example 'size' ). >>> PositiveInt . validate ( 'size' , - 1 ) ValidationError [ ValueError ]: Error validating [ size =- 1 ] . InvalidValue : should be positive . Function [ < lambda > ] returned [ False ] for value - 1. partial checkers: has_valid_type for type-only, and has_valid_value for value-only: assert PositiveInt . has_valid_type ( - 1 ) # -1 is an int assert not PositiveInt . has_valid_value ( - 1 ) # -1 < 0 Finally, you may wish to use is_vtype to check if anything is a VType : from vtypes import is_vtype assert is_vtype ( PositiveInt ) assert not is_vtype ( int ) assert not is_vtype ( 1 ) c - validators syntax \u00b6 There are many ways to declare validators: a single callable a single tuple (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) a list of such callables and tuples a dictionary where keys are <callable> , <error_msg> , or <failure_type> and values are one or two (tuple) of such elements. This is at least for the author, the most intuitive and readable style: ConstrainedInt = vtype ( 'ConstrainedInt' , int , { 'should be positive' : lambda x : x >= 0 , 'should be a multiple of 3' : lambda x : x % 3 }) Note that this syntax is valid8 simple syntax . If you wish to create even more compact callables, you may wish to look at mini_lambda . d - composition \u00b6 You can combine types, for example a nonempty string can be obtained by mixing NonEmpty and str : NonEmpty = vtype ( 'NonEmpty' , (), { 'should be non empty' : lambda x : len ( x ) > 0 }) \"\"\"A VType describing non-empty containers, with strictly positive length.\"\"\" NonEmptyStr = vtype ( 'NonEmptyStr' , ( NonEmpty , str ), ()) \"\"\"A VType for non-empty strings\"\"\" e - alternate coding style \u00b6 An alternate way to define VType s is to define a python class inheriting from VType . the validators can be provided as a class member named __validators__ the base type(s) can be either provided as superclass(es), or as a class member named __type__ . This provides an alternate style that developers might find handy in particular for entering docstrings and for making VTypes composition appear \"just like normal python inheritance\". from vtypes import VType class NonEmpty ( VType ): \"\"\"A VType describing non-empty containers, with strictly positive length.\"\"\" __validators__ = { 'should be non empty' : lambda x : len ( x ) > 0 } class NonEmptyStr ( NonEmpty , str ): \"\"\"A VType for non-empty strings\"\"\" class AlternateNonEmptyStr ( VType ): \"\"\"A VType for non-empty strings - alternate style\"\"\" __type__ = NonEmpty , str The vtypes work as expected: assert isinstance ( 'hoho' , NonEmptyStr ) assert not isinstance ( '' , NonEmptyStr ) assert not isinstance ( 1 , NonEmptyStr ) Main features \u00b6 Validate both type and value with isinstance , thanks to easy-to-write \"validating types\" has_valid_type and has_valid_value methods provided for easy auditing, as well as is_vtype Validation syntax fully compliant with valid8 . Compliant error message available through a validate() method v-types are composable so that creating a library of reusable elements is straightforward (note: should we provide one in this library based on valid8 library ?) Alternate class-style available to perform composition using inheritance, and write docstrings more easily. See Also \u00b6 checktypes , that was a great source of inspiration. The only reason I ended up recreating something new a couple years after discovering it, was that I really wanted to leverage the valid8 syntax for validators (as well as its standardized exceptions). Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-vtypes","title":"Home"},{"location":"#python-validating-types-vtypes","text":"Validating types for python - use isinstance() to validate both type and value. vtypes is a small library to define \"validating types\". These types can be used to add value validation on top of type checking anywhere where you usually rely on isinstance() . This can in particular be used to make validation schemas simpler and more readable, for example used in pyfields .","title":"python validating types (vtypes)"},{"location":"#installing","text":"> pip install vtypes","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#a-basics","text":"A VType is a combination of : a type name , for example 'PositiveInt' one or several base types : for example int . one or several validators : for example lambda x: x >= 0 For example we can create a positive int: from vtypes import vtype PositiveInt = vtype ( 'PositiveInt' , int , { 'should be positive' : lambda x : x >= 0 }) A VType 's main purpose is to behave like a type (therefore to be compliant with isinstance ) and to validate both type and values at the same time when isinstance is called: assert isinstance ( 1 , PositiveInt ) assert not isinstance ( - 1 , PositiveInt )","title":"a - basics"},{"location":"#b-goodies","text":"In addition to this primary feature, a VType provides a few handy methods: detailed error messages with validate (note: a variable name should be provided, for example 'size' ). >>> PositiveInt . validate ( 'size' , - 1 ) ValidationError [ ValueError ]: Error validating [ size =- 1 ] . InvalidValue : should be positive . Function [ < lambda > ] returned [ False ] for value - 1. partial checkers: has_valid_type for type-only, and has_valid_value for value-only: assert PositiveInt . has_valid_type ( - 1 ) # -1 is an int assert not PositiveInt . has_valid_value ( - 1 ) # -1 < 0 Finally, you may wish to use is_vtype to check if anything is a VType : from vtypes import is_vtype assert is_vtype ( PositiveInt ) assert not is_vtype ( int ) assert not is_vtype ( 1 )","title":"b - goodies"},{"location":"#c-validators-syntax","text":"There are many ways to declare validators: a single callable a single tuple (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) a list of such callables and tuples a dictionary where keys are <callable> , <error_msg> , or <failure_type> and values are one or two (tuple) of such elements. This is at least for the author, the most intuitive and readable style: ConstrainedInt = vtype ( 'ConstrainedInt' , int , { 'should be positive' : lambda x : x >= 0 , 'should be a multiple of 3' : lambda x : x % 3 }) Note that this syntax is valid8 simple syntax . If you wish to create even more compact callables, you may wish to look at mini_lambda .","title":"c - validators syntax"},{"location":"#d-composition","text":"You can combine types, for example a nonempty string can be obtained by mixing NonEmpty and str : NonEmpty = vtype ( 'NonEmpty' , (), { 'should be non empty' : lambda x : len ( x ) > 0 }) \"\"\"A VType describing non-empty containers, with strictly positive length.\"\"\" NonEmptyStr = vtype ( 'NonEmptyStr' , ( NonEmpty , str ), ()) \"\"\"A VType for non-empty strings\"\"\"","title":"d - composition"},{"location":"#e-alternate-coding-style","text":"An alternate way to define VType s is to define a python class inheriting from VType . the validators can be provided as a class member named __validators__ the base type(s) can be either provided as superclass(es), or as a class member named __type__ . This provides an alternate style that developers might find handy in particular for entering docstrings and for making VTypes composition appear \"just like normal python inheritance\". from vtypes import VType class NonEmpty ( VType ): \"\"\"A VType describing non-empty containers, with strictly positive length.\"\"\" __validators__ = { 'should be non empty' : lambda x : len ( x ) > 0 } class NonEmptyStr ( NonEmpty , str ): \"\"\"A VType for non-empty strings\"\"\" class AlternateNonEmptyStr ( VType ): \"\"\"A VType for non-empty strings - alternate style\"\"\" __type__ = NonEmpty , str The vtypes work as expected: assert isinstance ( 'hoho' , NonEmptyStr ) assert not isinstance ( '' , NonEmptyStr ) assert not isinstance ( 1 , NonEmptyStr )","title":"e - alternate coding style"},{"location":"#main-features","text":"Validate both type and value with isinstance , thanks to easy-to-write \"validating types\" has_valid_type and has_valid_value methods provided for easy auditing, as well as is_vtype Validation syntax fully compliant with valid8 . Compliant error message available through a validate() method v-types are composable so that creating a library of reusable elements is straightforward (note: should we provide one in this library based on valid8 library ?) Alternate class-style available to perform composition using inheritance, and write docstrings more easily.","title":"Main features"},{"location":"#see-also","text":"checktypes , that was a great source of inspiration. The only reason I ended up recreating something new a couple years after discovering it, was that I really wanted to leverage the valid8 syntax for validators (as well as its standardized exceptions). Do you like this library ? You might also like my other python libraries","title":"See Also"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-vtypes","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, help(symbol) will provide the latest up-to-date documentation. TODO \u00b6","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, help(symbol) will provide the latest up-to-date documentation.","title":"API reference"},{"location":"api_reference/#todo","text":"","title":"TODO"},{"location":"changelog/","text":"Changelog \u00b6 0.1.0 - TODO \u00b6 TODO","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#010-todo","text":"TODO","title":"0.1.0 - TODO"},{"location":"long_description/","text":"python validating types (vtypes) \u00b6 Validating types for python - use isinstance() to validate both type and value. The documentation for users is available here: https://smarie.github.io/python-vtypes/ A readme for developers is available here: https://github.com/smarie/python-vtypes","title":"python validating types (vtypes)"},{"location":"long_description/#python-validating-types-vtypes","text":"Validating types for python - use isinstance() to validate both type and value. The documentation for users is available here: https://smarie.github.io/python-vtypes/ A readme for developers is available here: https://github.com/smarie/python-vtypes","title":"python validating types (vtypes)"}]}